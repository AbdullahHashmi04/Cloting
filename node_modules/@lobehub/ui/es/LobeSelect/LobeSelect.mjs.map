{"version":3,"file":"LobeSelect.mjs","names":["mergedOptions: LobeSelectOptions","missingValueOptions: LobeSelectOption<any>[]","styles","option","content","Icon","baseStyle: React.CSSProperties","indices: number[]","menuStyles","currentIndex"],"sources":["../../src/LobeSelect/LobeSelect.tsx"],"sourcesContent":["'use client';\n\nimport { Select } from '@base-ui/react/select';\nimport { cx, useThemeMode } from 'antd-style';\nimport { Check, ChevronDown, Loader2, X } from 'lucide-react';\nimport {\n  type ChangeEvent,\n  type HTMLAttributes,\n  type KeyboardEvent,\n  type MouseEvent,\n  type MutableRefObject,\n  type Ref,\n} from 'react';\nimport { isValidElement, memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { Virtualizer } from 'virtua';\n\nimport Icon from '@/Icon';\nimport { styles as menuStyles } from '@/Menu/sharedStyle';\n\nimport { styles, triggerVariants } from './style';\nimport {\n  type LobeSelectOption,\n  type LobeSelectOptionGroup,\n  type LobeSelectOptions,\n  type LobeSelectProps,\n} from './type';\n\nconst isGroupOption = <Value,>(\n  option: LobeSelectOption<Value> | LobeSelectOptionGroup<Value>,\n): option is LobeSelectOptionGroup<Value> =>\n  Boolean((option as LobeSelectOptionGroup<Value>).options);\n\nconst getOptionSearchText = <Value,>(option: LobeSelectOption<Value>) => {\n  if (typeof option.label === 'string' || typeof option.label === 'number') {\n    return String(option.label);\n  }\n  if (typeof option.value === 'string' || typeof option.value === 'number') {\n    return String(option.value);\n  }\n  if (option.title) return option.title;\n  return '';\n};\n\nconst escapeRegExp = (value: string) => value.replaceAll(/[$()*+.?[\\\\\\]^{|}]/g, '\\\\$&');\n\nconst splitBySeparators = (value: string, separators?: string[]) => {\n  if (!separators || separators.length === 0) return [value];\n  const pattern = separators.map(escapeRegExp).join('|');\n  return value.split(new RegExp(pattern, 'g'));\n};\n\nconst countVirtualItems = (items: LobeSelectOptions) =>\n  items.reduce((count, item) => {\n    if (isGroupOption(item)) {\n      return count + item.options.length + 1;\n    }\n    return count + 1;\n  }, 0);\n\nconst isValueEmpty = (value: unknown) => value === null || value === undefined || value === '';\n\nconst LobeSelect = memo<LobeSelectProps<any>>(\n  ({\n    allowClear,\n    autoFocus,\n    className,\n    classNames,\n    defaultOpen,\n    defaultValue,\n    disabled,\n    id,\n    labelRender,\n    listHeight = 512,\n    listItemHeight,\n    loading,\n    mode,\n    name,\n    onChange,\n    onOpenChange,\n    onSelect,\n    open,\n    optionRender,\n    options,\n    placeholder,\n    popupClassName,\n    popupMatchSelectWidth,\n    prefix,\n    readOnly,\n    required,\n    behaviorVariant = 'default',\n    selectedIndicatorVariant = 'check',\n    shadow,\n    showSearch,\n    size = 'middle',\n    style,\n    suffixIcon,\n    suffixIconProps,\n    tokenSeparators,\n    value,\n    variant,\n    virtual,\n  }) => {\n    const { isDarkMode } = useThemeMode();\n    const resolvedVariant = variant ?? (isDarkMode ? 'filled' : 'outlined');\n    const isMultiple = mode === 'multiple' || mode === 'tags';\n    const isItemAligned = behaviorVariant === 'item-aligned';\n\n    const [uncontrolledValue, setUncontrolledValue] = useState<any>(() => {\n      if (defaultValue !== undefined) return defaultValue;\n      return isMultiple ? [] : null;\n    });\n\n    const normalizeValue = useCallback(\n      (nextValue: any) => {\n        if (isMultiple) {\n          if (Array.isArray(nextValue)) return nextValue;\n          if (nextValue === null || nextValue === undefined) return [];\n          return [nextValue];\n        }\n        if (Array.isArray(nextValue)) return nextValue[0] ?? null;\n        return nextValue === undefined ? null : nextValue;\n      },\n      [isMultiple],\n    );\n\n    const mergedValue = value !== undefined ? value : uncontrolledValue;\n    const normalizedValue = useMemo(\n      () => normalizeValue(mergedValue),\n      [mergedValue, normalizeValue],\n    );\n    const valueArray = useMemo(\n      () =>\n        isMultiple\n          ? (normalizedValue as any[])\n          : isValueEmpty(normalizedValue)\n            ? []\n            : [normalizedValue],\n      [isMultiple, normalizedValue],\n    );\n\n    const [extraOptions, setExtraOptions] = useState<LobeSelectOption<any>[]>([]);\n\n    useEffect(() => {\n      if (mode !== 'tags' && extraOptions.length > 0) {\n        setExtraOptions([]);\n      }\n    }, [mode, extraOptions.length]);\n\n    const { resolvedOptions, optionMap } = useMemo(() => {\n      const baseOptions = options ?? [];\n      const optionValueMap = new Map<any, LobeSelectOption<any>>();\n\n      const addOption = (item: LobeSelectOption<any>) => {\n        if (!optionValueMap.has(item.value)) {\n          optionValueMap.set(item.value, item);\n        }\n      };\n\n      const walkOptions = (items: LobeSelectOptions) => {\n        items.forEach((item) => {\n          if (isGroupOption(item)) {\n            item.options.forEach(addOption);\n          } else {\n            addOption(item);\n          }\n        });\n      };\n\n      walkOptions(baseOptions);\n\n      const filteredExtraOptions = extraOptions.filter((item) => !optionValueMap.has(item.value));\n      filteredExtraOptions.forEach(addOption);\n\n      const mergedOptions: LobeSelectOptions = [...baseOptions, ...filteredExtraOptions];\n\n      const missingValueOptions: LobeSelectOption<any>[] = valueArray\n        .filter((val) => !optionValueMap.has(val))\n        .map((val) => ({\n          label: String(val),\n          value: val,\n        }));\n      missingValueOptions.forEach(addOption);\n\n      return {\n        optionMap: optionValueMap,\n        resolvedOptions: missingValueOptions.length\n          ? [...mergedOptions, ...missingValueOptions]\n          : mergedOptions,\n      };\n    }, [extraOptions, options, valueArray]);\n\n    const [uncontrolledOpen, setUncontrolledOpen] = useState(Boolean(defaultOpen));\n\n    useEffect(() => {\n      if (open !== undefined) {\n        setUncontrolledOpen(open);\n      }\n    }, [open]);\n\n    const mergedOpen = open ?? uncontrolledOpen;\n\n    const handleOpenChange = useCallback(\n      (nextOpen: boolean) => {\n        onOpenChange?.(nextOpen);\n        if (open === undefined) {\n          setUncontrolledOpen(nextOpen);\n        }\n      },\n      [onOpenChange, open],\n    );\n\n    const [searchValue, setSearchValue] = useState('');\n    const shouldShowSearch = Boolean(showSearch || mode === 'tags');\n\n    useEffect(() => {\n      if (!mergedOpen) setSearchValue('');\n    }, [mergedOpen]);\n\n    const getOption = useCallback(\n      (optionValue: any): LobeSelectOption<any> => {\n        const matched = optionMap.get(optionValue);\n        if (matched) return matched;\n        if (optionValue && typeof optionValue === 'object' && 'label' in optionValue) {\n          return {\n            label: (optionValue as any).label,\n            value: optionValue,\n          };\n        }\n        return {\n          label: String(optionValue),\n          value: optionValue,\n        };\n      },\n      [optionMap],\n    );\n\n    const previousValueRef = useRef<any>(normalizedValue);\n\n    useEffect(() => {\n      previousValueRef.current = normalizedValue;\n    }, [normalizedValue]);\n\n    const handleValueChange = useCallback(\n      (nextValue: any) => {\n        const normalizedNextValue = normalizeValue(nextValue);\n        const previousValue = previousValueRef.current;\n\n        if (isMultiple) {\n          const prevValues = Array.isArray(previousValue) ? previousValue : [];\n          const nextValues = Array.isArray(normalizedNextValue) ? normalizedNextValue : [];\n          const addedValues = nextValues.filter(\n            (val) => !prevValues.some((prev) => Object.is(prev, val)),\n          );\n\n          addedValues.forEach((val) => {\n            onSelect?.(val, getOption(val));\n          });\n\n          if (value === undefined) {\n            setUncontrolledValue(nextValues);\n          }\n          onChange?.(\n            nextValues,\n            nextValues.map((val) => getOption(val)),\n          );\n        } else {\n          if (\n            !isValueEmpty(normalizedNextValue) &&\n            !Object.is(previousValue, normalizedNextValue)\n          ) {\n            onSelect?.(normalizedNextValue, getOption(normalizedNextValue));\n          }\n          if (value === undefined) {\n            setUncontrolledValue(normalizedNextValue);\n          }\n          onChange?.(\n            normalizedNextValue,\n            isValueEmpty(normalizedNextValue) ? undefined : getOption(normalizedNextValue),\n          );\n        }\n\n        previousValueRef.current = normalizedNextValue;\n      },\n      [getOption, isMultiple, normalizeValue, onChange, onSelect, value],\n    );\n\n    const appendTagValues = useCallback(\n      (rawValues: string[]) => {\n        const valuesToAdd = rawValues.map((val) => val.trim()).filter(Boolean);\n        if (!valuesToAdd.length) return;\n\n        const nextValues = [...valueArray];\n        const newOptionValues = valuesToAdd.filter((val) => !optionMap.has(val));\n\n        if (newOptionValues.length > 0) {\n          setExtraOptions((prev) => {\n            const existingValues = new Set(prev.map((item) => item.value));\n            const merged = [...prev];\n            newOptionValues.forEach((val) => {\n              if (!existingValues.has(val)) {\n                merged.push({ label: val, value: val });\n              }\n            });\n            return merged;\n          });\n        }\n\n        valuesToAdd.forEach((val) => {\n          if (!nextValues.some((item) => Object.is(item, val))) {\n            nextValues.push(val);\n          }\n        });\n\n        if (nextValues.length !== valueArray.length) {\n          handleValueChange(nextValues);\n        }\n      },\n      [handleValueChange, optionMap, valueArray],\n    );\n\n    const handleSearchChange = useCallback(\n      (event: ChangeEvent<HTMLInputElement>) => {\n        const nextValue = event.target.value;\n        if (mode === 'tags') {\n          const parts = splitBySeparators(nextValue, tokenSeparators);\n          if (parts.length > 1) {\n            const pending = parts.pop() ?? '';\n            appendTagValues(parts.filter(Boolean));\n            setSearchValue(pending);\n            return;\n          }\n        }\n        setSearchValue(nextValue);\n      },\n      [appendTagValues, mode, tokenSeparators],\n    );\n\n    const handleSearchKeyDown = useCallback(\n      (event: KeyboardEvent<HTMLInputElement>) => {\n        event.stopPropagation();\n\n        if (event.key === 'Escape') {\n          handleOpenChange(false);\n          return;\n        }\n\n        if (mode !== 'tags') return;\n\n        if (event.key === 'Enter') {\n          event.preventDefault();\n          event.stopPropagation();\n          appendTagValues([searchValue]);\n          setSearchValue('');\n          return;\n        }\n\n        if (tokenSeparators?.includes(event.key)) {\n          event.preventDefault();\n          event.stopPropagation();\n          appendTagValues([searchValue]);\n          setSearchValue('');\n        }\n      },\n      [appendTagValues, handleOpenChange, mode, searchValue, tokenSeparators],\n    );\n\n    const filteredOptions = useMemo(() => {\n      if (!shouldShowSearch || !searchValue.trim()) return resolvedOptions;\n      const query = searchValue.trim().toLowerCase();\n\n      const filterItems = (items: LobeSelectOptions): LobeSelectOptions => {\n        const filtered = items\n          .map((item) => {\n            if (isGroupOption(item)) {\n              const groupItems = item.options.filter((option) =>\n                getOptionSearchText(option).toLowerCase().includes(query),\n              );\n              if (!groupItems.length) return null;\n              return { ...item, options: groupItems };\n            }\n            return getOptionSearchText(item).toLowerCase().includes(query) ? item : null;\n          })\n          .filter(Boolean) as LobeSelectOptions;\n\n        return filtered;\n      };\n\n      return filterItems(resolvedOptions);\n    }, [resolvedOptions, searchValue, shouldShowSearch]);\n\n    const renderValue = useCallback(\n      (currentValue: any) => {\n        const resolved = normalizeValue(currentValue);\n        const placeholderNode =\n          placeholder === undefined ? null : (\n            <span className={styles.valueText}>{placeholder}</span>\n          );\n\n        if (isMultiple) {\n          const values = Array.isArray(resolved) ? resolved : [];\n          if (values.length === 0) return placeholderNode;\n          return (\n            <span className={styles.tags}>\n              {values.map((val, index) => {\n                const option = getOption(val);\n                const content = labelRender ? labelRender(option) : (option.label ?? String(val));\n                return (\n                  <span className={styles.tag} key={`${String(val)}-${index}`}>\n                    {content}\n                  </span>\n                );\n              })}\n            </span>\n          );\n        }\n\n        if (isValueEmpty(resolved)) return placeholderNode;\n        const option = getOption(resolved);\n        const content = labelRender ? labelRender(option) : (option.label ?? String(resolved));\n        return <span className={styles.valueText}>{content}</span>;\n      },\n      [getOption, isMultiple, labelRender, normalizeValue, placeholder],\n    );\n\n    const hasValue = isMultiple ? valueArray.length > 0 : !isValueEmpty(normalizedValue);\n    const showClear = Boolean(allowClear && hasValue && !disabled && !readOnly);\n\n    const handleClear = useCallback(\n      (event: MouseEvent) => {\n        event.preventDefault();\n        event.stopPropagation();\n        handleValueChange(isMultiple ? [] : null);\n      },\n      [handleValueChange, isMultiple],\n    );\n\n    const prefixNode = useMemo(() => {\n      if (prefix === undefined || prefix === null) return null;\n      if (isValidElement(prefix) || typeof prefix === 'string' || typeof prefix === 'number') {\n        return prefix;\n      }\n      return <Icon icon={prefix as any} size={'small'} />;\n    }, [prefix]);\n\n    const suffixIconNode = useMemo(() => {\n      if (loading) {\n        return <Icon spin icon={Loader2} size={'small'} />;\n      }\n      if (suffixIcon === null) return null;\n      if (\n        isValidElement(suffixIcon) ||\n        typeof suffixIcon === 'string' ||\n        typeof suffixIcon === 'number'\n      ) {\n        return suffixIcon;\n      }\n      return (\n        <Icon\n          icon={(suffixIcon as any) || ChevronDown}\n          size={'small'}\n          {...suffixIconProps}\n          style={{\n            pointerEvents: 'none',\n            ...suffixIconProps?.style,\n          }}\n        />\n      );\n    }, [loading, suffixIcon, suffixIconProps]);\n\n    const popupStyle = useMemo(() => {\n      const maxHeight = isItemAligned ? '80vh' : `${listHeight}px`;\n      const baseStyle: React.CSSProperties = {\n        maxHeight,\n        maxWidth: 'var(--available-width)',\n        minWidth: 'var(--anchor-width)',\n        ['--lobe-select-popup-max-height' as any]: maxHeight,\n      };\n\n      if (popupMatchSelectWidth === undefined || popupMatchSelectWidth === true) {\n        return baseStyle;\n      }\n      if (typeof popupMatchSelectWidth === 'number') {\n        return {\n          ...baseStyle,\n          minWidth: popupMatchSelectWidth,\n          width: popupMatchSelectWidth,\n        };\n      }\n      return {\n        ...baseStyle,\n        minWidth: 'max-content',\n      };\n    }, [isItemAligned, listHeight, popupMatchSelectWidth]);\n\n    const triggerClassName = cx(\n      triggerVariants({ shadow, size, variant: resolvedVariant }),\n      className,\n      classNames?.root,\n      classNames?.trigger,\n    );\n\n    const listRef = useRef<HTMLDivElement | null>(null);\n    const pointerScrollRef = useRef(false);\n    const pointerScrollTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n    const renderVirtualItem = useCallback((props: HTMLAttributes<HTMLDivElement>) => {\n      const { ref, ...rest } = props as HTMLAttributes<HTMLDivElement> & {\n        ref?: Ref<HTMLDivElement>;\n      };\n\n      return (\n        <div\n          {...rest}\n          ref={(node) => {\n            if (node) {\n              node.scrollIntoView = (...args) => {\n                if (!pointerScrollRef.current) {\n                  HTMLElement.prototype.scrollIntoView.call(node, ...args);\n                }\n              };\n            }\n\n            if (typeof ref === 'function') {\n              ref(node);\n            } else if (ref && 'current' in ref) {\n              (ref as MutableRefObject<HTMLDivElement | null>).current = node;\n            }\n          }}\n        />\n      );\n    }, []);\n\n    const markPointerScroll = useCallback(() => {\n      pointerScrollRef.current = true;\n      if (pointerScrollTimeoutRef.current) {\n        clearTimeout(pointerScrollTimeoutRef.current);\n      }\n      pointerScrollTimeoutRef.current = setTimeout(() => {\n        pointerScrollRef.current = false;\n      }, 120);\n    }, []);\n\n    const handleListScroll = useCallback(() => {\n      if (!virtual || !pointerScrollRef.current) return;\n      const listElement = listRef.current;\n      const activeElement = document.activeElement;\n      if (listElement && activeElement && listElement.contains(activeElement)) {\n        listElement.focus({ preventScroll: true });\n      }\n    }, [virtual]);\n\n    useEffect(() => {\n      return () => {\n        if (pointerScrollTimeoutRef.current) {\n          clearTimeout(pointerScrollTimeoutRef.current);\n        }\n      };\n    }, []);\n    const virtualListStyle = useMemo(() => {\n      if (!virtual) return undefined;\n      const rowCount = countVirtualItems(filteredOptions);\n      const maxVisibleRows = 6;\n      const estimatedRowHeight =\n        listItemHeight ?? (size === 'large' ? 40 : size === 'small' ? 28 : 32);\n      const visibleRows = Math.min(Math.max(rowCount, 1), maxVisibleRows);\n      const estimatedHeight = visibleRows * estimatedRowHeight + 8;\n\n      return {\n        height: `min(${estimatedHeight}px, var(--lobe-select-available-height, var(--available-height)))`,\n      };\n    }, [filteredOptions, listItemHeight, size, virtual]);\n\n    const keepMountedIndices = useMemo(() => {\n      if (!virtual || valueArray.length === 0) return undefined;\n      const selectedSet = new Set(valueArray);\n      const indices: number[] = [];\n      let index = 0;\n\n      filteredOptions.forEach((item) => {\n        if (isGroupOption(item)) {\n          if (item.options.some((option) => selectedSet.has(option.value))) {\n            indices.push(index);\n          }\n          index += 1;\n          return;\n        }\n\n        if (selectedSet.has(item.value)) {\n          indices.push(index);\n        }\n        index += 1;\n      });\n\n      return indices.length ? indices : undefined;\n    }, [filteredOptions, valueArray, virtual]);\n\n    const itemTextClassName = cx(\n      optionRender ? menuStyles.itemContent : menuStyles.label,\n      styles.itemText,\n      classNames?.itemText,\n    );\n\n    const isBoldIndicator = selectedIndicatorVariant === 'bold';\n    let optionIndex = 0;\n    const renderOptions = (items: LobeSelectOptions) =>\n      items.map((item, index) => {\n        if (isGroupOption(item)) {\n          return (\n            <Select.Group className={cx(styles.group, classNames?.group)} key={`group-${index}`}>\n              <Select.GroupLabel\n                className={cx(menuStyles.groupLabel, styles.groupLabel, classNames?.groupLabel)}\n              >\n                {item.label}\n              </Select.GroupLabel>\n              {item.options.map((option) => {\n                const currentIndex = optionIndex++;\n                return (\n                  <Select.Item\n                    disabled={option.disabled}\n                    key={`${String(option.value)}-${currentIndex}`}\n                    label={getOptionSearchText(option)}\n                    render={virtual ? renderVirtualItem : undefined}\n                    value={option.value}\n                    className={cx(\n                      menuStyles.item,\n                      styles.item,\n                      isBoldIndicator && styles.itemBoldSelected,\n                      classNames?.item,\n                      classNames?.option,\n                      option.className,\n                    )}\n                    style={{\n                      minHeight: listItemHeight,\n                      ...option.style,\n                    }}\n                  >\n                    <Select.ItemText className={itemTextClassName}>\n                      {optionRender ? optionRender(option, { index: currentIndex }) : option.label}\n                    </Select.ItemText>\n                    {!isBoldIndicator && (\n                      <Select.ItemIndicator\n                        className={cx(styles.itemIndicator, classNames?.itemIndicator)}\n                      >\n                        <Icon icon={Check} size={'small'} />\n                      </Select.ItemIndicator>\n                    )}\n                  </Select.Item>\n                );\n              })}\n            </Select.Group>\n          );\n        }\n\n        const currentIndex = optionIndex++;\n        return (\n          <Select.Item\n            disabled={item.disabled}\n            key={`${String(item.value)}-${currentIndex}`}\n            label={getOptionSearchText(item)}\n            render={virtual ? renderVirtualItem : undefined}\n            value={item.value}\n            className={cx(\n              menuStyles.item,\n              styles.item,\n              isBoldIndicator && styles.itemBoldSelected,\n              classNames?.item,\n              classNames?.option,\n              item.className,\n            )}\n            style={{\n              minHeight: listItemHeight,\n              ...item.style,\n            }}\n          >\n            <Select.ItemText className={itemTextClassName}>\n              {optionRender ? optionRender(item, { index: currentIndex }) : item.label}\n            </Select.ItemText>\n            {!isBoldIndicator && (\n              <Select.ItemIndicator className={cx(styles.itemIndicator, classNames?.itemIndicator)}>\n                <Icon icon={Check} size={'small'} />\n              </Select.ItemIndicator>\n            )}\n          </Select.Item>\n        );\n      });\n\n    return (\n      <Select.Root\n        disabled={disabled}\n        id={id}\n        modal={isItemAligned}\n        multiple={isMultiple}\n        name={name}\n        open={mergedOpen}\n        readOnly={readOnly}\n        required={required}\n        value={normalizedValue}\n        onOpenChange={handleOpenChange}\n        onValueChange={handleValueChange}\n      >\n        <Select.Trigger\n          autoFocus={autoFocus}\n          className={triggerClassName}\n          disabled={disabled}\n          style={style}\n        >\n          {prefixNode !== null && prefixNode !== undefined && (\n            <span className={cx(styles.prefix, classNames?.prefix)}>{prefixNode}</span>\n          )}\n          <Select.Value className={cx(styles.value, classNames?.value)}>{renderValue}</Select.Value>\n          <span className={cx(styles.suffix, classNames?.suffix)}>\n            {showClear && (\n              <span\n                className={cx(styles.clear, classNames?.clear)}\n                data-role=\"lobe-select-clear\"\n                onClick={handleClear}\n              >\n                <Icon icon={X} size={'small'} />\n              </span>\n            )}\n            {suffixIconNode !== null && suffixIconNode !== undefined && (\n              <Select.Icon className={cx(styles.icon, classNames?.icon)}>\n                {suffixIconNode}\n              </Select.Icon>\n            )}\n          </span>\n        </Select.Trigger>\n\n        <Select.Portal>\n          <Select.Positioner\n            align=\"start\"\n            alignItemWithTrigger={isItemAligned}\n            className={styles.positioner}\n            side=\"bottom\"\n            sideOffset={6}\n          >\n            <Select.Popup\n              style={popupStyle}\n              className={cx(\n                menuStyles.popup,\n                styles.popup,\n                popupClassName,\n                classNames?.popup,\n                classNames?.dropdown,\n              )}\n            >\n              {shouldShowSearch && (\n                <div className={cx(styles.search, classNames?.search)}>\n                  <input\n                    className={styles.searchInput}\n                    placeholder={typeof placeholder === 'string' ? placeholder : undefined}\n                    value={searchValue}\n                    onChange={handleSearchChange}\n                    onKeyDown={handleSearchKeyDown}\n                  />\n                </div>\n              )}\n              {(() => {\n                const content =\n                  filteredOptions.length > 0 ? (\n                    renderOptions(filteredOptions)\n                  ) : (\n                    <div\n                      className={cx(\n                        menuStyles.item,\n                        menuStyles.empty,\n                        styles.empty,\n                        classNames?.empty,\n                      )}\n                    >\n                      No data\n                    </div>\n                  );\n\n                if (!virtual || filteredOptions.length === 0) {\n                  return (\n                    <Select.List\n                      className={cx(styles.list, classNames?.list)}\n                      data-virtual={virtual || undefined}\n                    >\n                      {content}\n                    </Select.List>\n                  );\n                }\n\n                return (\n                  <Select.List\n                    className={cx(styles.list, classNames?.list)}\n                    data-virtual={virtual || undefined}\n                    ref={listRef}\n                    style={virtualListStyle}\n                    tabIndex={virtual ? -1 : undefined}\n                    onPointerDown={virtual ? markPointerScroll : undefined}\n                    onScroll={virtual ? handleListScroll : undefined}\n                    onTouchMove={virtual ? markPointerScroll : undefined}\n                    onWheel={virtual ? markPointerScroll : undefined}\n                  >\n                    <Virtualizer itemSize={listItemHeight} keepMounted={keepMountedIndices}>\n                      {content}\n                    </Virtualizer>\n                  </Select.List>\n                );\n              })()}\n            </Select.Popup>\n          </Select.Positioner>\n        </Select.Portal>\n      </Select.Root>\n    );\n  },\n);\n\nLobeSelect.displayName = 'LobeSelect';\n\nexport default LobeSelect;\n"],"mappings":"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"}