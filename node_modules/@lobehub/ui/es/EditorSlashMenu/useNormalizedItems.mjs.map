{"version":3,"file":"useNormalizedItems.mjs","names":["groups: EditorSlashMenuGroup[]","buffer: EditorSlashMenuOption[]"],"sources":["../../src/EditorSlashMenu/useNormalizedItems.ts"],"sourcesContent":["import { useMemo } from 'react';\n\nimport type { EditorSlashMenuGroup, EditorSlashMenuItems, EditorSlashMenuOption } from './type';\nimport { isGroup } from './utils';\n\nexport const useNormalizedItems = (items: EditorSlashMenuItems) => {\n  const resolvedItems = useMemo(() => {\n    const hasAnyGroup = items.some(isGroup);\n    if (!hasAnyGroup) return items as EditorSlashMenuOption[];\n\n    // Normalize: keep order, but ensure all entries are groups.\n    const groups: EditorSlashMenuGroup[] = [];\n    let buffer: EditorSlashMenuOption[] = [];\n\n    const flush = () => {\n      if (buffer.length) {\n        groups.push({ items: buffer });\n        buffer = [];\n      }\n    };\n\n    for (const entry of items) {\n      if (isGroup(entry)) {\n        flush();\n        groups.push(entry);\n      } else {\n        buffer.push(entry);\n      }\n    }\n    flush();\n\n    return groups;\n  }, [items]);\n\n  const hasAnyIcon = useMemo(() => {\n    const walk = (entry: EditorSlashMenuOption | EditorSlashMenuGroup): boolean => {\n      if (isGroup(entry)) return entry.items.some(walk as any);\n      return Boolean(entry.icon);\n    };\n    return items.some(walk as any);\n  }, [items]);\n\n  return { hasAnyIcon, resolvedItems };\n};\n"],"mappings":";;;;AAKA,MAAa,sBAAsB,UAAgC;CACjE,MAAM,gBAAgB,cAAc;AAElC,MAAI,CADgB,MAAM,KAAK,QAAQ,CACrB,QAAO;EAGzB,MAAMA,SAAiC,EAAE;EACzC,IAAIC,SAAkC,EAAE;EAExC,MAAM,cAAc;AAClB,OAAI,OAAO,QAAQ;AACjB,WAAO,KAAK,EAAE,OAAO,QAAQ,CAAC;AAC9B,aAAS,EAAE;;;AAIf,OAAK,MAAM,SAAS,MAClB,KAAI,QAAQ,MAAM,EAAE;AAClB,UAAO;AACP,UAAO,KAAK,MAAM;QAElB,QAAO,KAAK,MAAM;AAGtB,SAAO;AAEP,SAAO;IACN,CAAC,MAAM,CAAC;AAUX,QAAO;EAAE,YARU,cAAc;GAC/B,MAAM,QAAQ,UAAiE;AAC7E,QAAI,QAAQ,MAAM,CAAE,QAAO,MAAM,MAAM,KAAK,KAAY;AACxD,WAAO,QAAQ,MAAM,KAAK;;AAE5B,UAAO,MAAM,KAAK,KAAY;KAC7B,CAAC,MAAM,CAAC;EAEU;EAAe"}